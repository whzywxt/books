## 第16章 C预处理器和C库

预处理指令：`#define、#include、#ifdef、#else、#endif、#ifndef、#if、#elif、#line、#error、#pragma`

关键字：`_Generic、_Noreturn、_Static_assert`

函数/宏：`sqrt()、atan()、atan2()、exit()、atexit()、assert()、memcpy()、memmove()、va_start()、va_arg()、va_copy()、va_end()`

C语言建立在适当的关键字、表达式、语句以及使用它们的规则上。

C预处理器在程序执行之前查看程序（故称之为预处理器）。根据程序中的预处理指令，预处理器把符号缩写替换成其表示的内容。
预处理器可以包含程序所需的其他文件，可以选择让编译器查看哪些代码。
预处理器并不知道C。
基本上它的工作是把一些文本转换成另一些文本。


### 16.1 翻译程序的第一步

首先，编译器把源代码中出现的字符映射到元字符集。该过程处理多字节字符和三字符序列--字符扩展让C更加国际化。

第二，编译器定位每个反斜杠后面跟着换行符的示例（源代码文件中“Enter”键所生成的换行符），并删除它们。

第三，编译器把文本划分成预处理记号序列、空白序列和注释序列（记号是由空格、制表符或换行符分隔的项）。编译器将用一个空格字符替换每一条注释。

最后，程序已经准备好进入预处理阶段，预处理器查找一行中以#号开始的预处理指令。

### 16.2 明示常量：#define

ANSI和后来的标准都允许#号前面由空格或制表符，而且还允许在#和指令的其余部分之间由空格。
但是旧版本的C要求指令从一行最左边开始，而且#和指令其余部分之间不能有空格。
指令可以出现在源文件的任何地方，其定义从指令出现的地方到该文件末尾有效。

预处理指令从#开始运行，到后面的第1个换行符为止。即，指令的长度仅限于一行。

宏的名称中不允许有空格，而且必须遵守C变量的命名规则：只能使用字符、数字和下划线（_）字符，而且首字符不能是数字。

一旦预处理器在程序中找到宏的示示例后，就会用替换体代替宏（也有例外）。如果替换的字符串中还包含宏，则继续替换这些宏。唯一例外的是双引号中的宏。
从宏变成最终替换文本的过程称为宏展开（macro expansion）。

在C中，非自动数组的大小应该是整型常量表达式，即表示数组大小的必须是整型常量的组合（如5）、枚举常量和sizeof表达式，
不包括const声明的值（但是C++中可以把const值作为常量表达式的一部分）。

#define 宏的作用域从它在文件中的声明处开始，直到用 #undef 指令取消宏为止，或延伸至文件尾（以二者中先满足的条件作为宏作用域的结束）。
*另外，如果宏通过头文件引入，那么 #define 在文件中的位置取决于 #include 指令的位置。*

#### 重定义常量
先把LIMIT定义为20，稍后在该文件中又把它定义为25 。这个过程称为重定义常量。

*如果确实需要重定义常量，使用const关键字和作用域规则更容易些。*

### 16.3 在 #define 中使用参数

在#define中使用参数可以创建外形和作用与函数类似的类函数宏。带有参数的宏看上去很像函数，因为这样的宏也使用圆括号。
类函数宏定义的圆括号中可以有一个或多个参数，随后这些参数出现在替换体中。

示例：`#define SQUARE(X) X*X`

程序中使用：`z = SQUARE(2);`

#### 用宏参数创建字符串：`#`运算符

类函数宏：
`#define PSQR(X) printf("The square of X is %d.\n", ((X)*(X)));`

假设使用：
`PSQR(8);`

输出为：
`The square of X is 64.`

注意双引号字符串中的X被视为普通文本，而不是一个可被替换的记号。

C允许在字符串中包含宏参数。在类函数宏的替换中 `#`号作为一个预处理运算符。

#### 预处理器黏合剂：##运算符

与 `#` 运算符类似，`##` 运算符可用于类函数宏的替换。而且，`##` 还可用于对象宏的替换部分。`##` 运算符把两个记号组合成一个记号。

例如：`#define XNAME(n) x##n` ，然后，宏 `XNAME(3)` 讲展开为 `x3` 。

[glue.c](glue.c)

#### 变参宏：... 和 __VA_ARGS__

通常把宏参数列表中**最后的参数**写成省略号来实现这一功能。预定义宏 `__VA_ARGS__` 可用在替换部分中，表明省略号代表什么。

例如，定义 `#define PR(...) printf(__VA_ARGS__)`

### 16.4 宏和函数的选择

有些编程任务既可以用带参数的宏完成，也可以用函数完成。使用宏比普通函数复杂一些，稍有不慎会产生奇怪的副作用。

宏和函数的选择实际上是空间和时间的权衡。宏生成内联代码，即在程序中生成语句。
如果调用20次宏，即在程序中插入20行代码。如果调用函数20次，程序中只有一份函数语句的副本，所以节省了空间。
另一方面，程序的控制必须跳转至函数内，随后再返回主调程序，这显然比内联代码花费更多的时间。

宏的一个优点是，不用担心变量类型（因为宏处理的是字符串，而不是实际的值）。

C99 提供了第3种可替换的方法--内联函数。

对于简单的函数，程序员通常使用宏，如：
```c
#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))
#define ABS(X) ((X) < 0 ? -(X) : (X))
#define ISSIGN(X) ((X) == '+' || (X) == '-' ? 1 : 0)
```
注意事项：
- 宏名称中不允许有空格，但是在替换字符串中可以有空格。ANSI C 允许在参数列表中使用空格。
- 用圆括号把宏的参数和整个替换体括起来。这样能确保被括起来的部分在下面这样的表达式中正确的展开，如：`forks = 2 * MAX(guests + 3, last);`
- 用大写字母表示宏函数的名称。该惯例不如用大写字母表示宏常量应用广泛。但是，大写字母可以提醒程序员注意，宏可能产生副作用。 

打算使用宏来加快程序的运行速度，首先需确定使用宏和使用函数是否会导致较大的差异。
在程序中只使用一次的宏无法明显减少程序的运行是按。在嵌套循环中使用宏更有助于提高效率。
建议使用**系统提供的程序分析器**来找出程序中最耗时的部分。

### 16.5 文件包含：#include
当预处理器发现 `#include` 指令时，会查找后面的文件名并把文件的内容包含到当前文件中，即替换源文件中的 `#include` 指令。相当于把被包含文件的全部内容输入到源文件 `#include` 指令所在位置。

`#include` 指令有两种形式：
- 文件名在尖括号中：
`#include <stdio.h>`
- 文件名在双引号中：
`#include "mystuff.h"`

在UNIX系统中，*尖括号*告诉预处理器在标准系统目录中查找该文件。
*双引号*告诉预处理器首先在当前目录中（或文件名中指定的其它目录）查找该文件，如果未找到再查找标准系统目录。
但是具体查找哪个目录取决于编译器的设定，有些编译器会搜索源代码文件所在的目录，有些编译器则搜索当前的工作目录，还有些搜索项目文件所在的目录。

尖括号和双引号，区别不是很重要的。只影响编译时预处理阶段的运行，对程序最终效果没有影响。

包含一个大型头文件不一定显著增加程序的大小。在大部分情况下，头文件的内容是编译器生成最终代码时所需的信息，而不是添加到最终代码中的材料。

#### 使用头文件

浏览任何一个标准头文件都可以了解文件的基本信息。头文件中最常用的形式如下：
- 明示常量
- 宏函数
- 函数声明
- 结构模板定义，如，标准I/O函数使用的FILE结构，该结构中包含了文件和文件缓冲区相关的信息。FILE结构在头文件 `stdio.h` 中。
- 类型定义，标准I/O函数使用指向FILE的指针作为参数。通常，`stdio.h` 用 `#define` 或 `typedef` 把FILE定义为指向结构的指针。类似地，`size_t` 和 `time_t` 类型也定义在头文件中。

### 16.6 其他指令

程序员可能要为不同的工作环境准备C程序和C库包。不同的环境可能使用不同的代码类型。
预处理器提供一些指令，程序员通过修改#define的值，即可生成可移植的代码。

#undef 指令取消之前的 #define 定义。

#if、#ifdef、#ifndef、#else、#elif和#endif指令用于指定什么情况下编写哪些代码。

#line 指令用于重置行和文件信息。

#error 指指令用于给出错误消息。

#pragma 指令用于向编译器发出指令。

#### 条件编译

##### 3.#if 和 #elif 指令
`#if` 后面跟整型常量表达式，如果表达式为非零，则表达式为真。可以在指令中使用C的关系运算符和逻辑运算符。
```c
#if SYS == 1
#include "ibm.h"
#endif

#if defined (IBMPC)
#include "ibmpc.h"
#elif defined (VAX)
#include "vax.h"
#elif defined (MAC)
#include "mac.h"
#else
#include "general.h"
#endif
```

#### 预定义宏

预定义宏
|宏|含义|
|----|----|
|`__DATE__`|预处理的日期（"Mmm dd yyyy" 形式的字符串面量，如 Nov 23 2013）|
|`__FILE__`|表示当前源代码文件名的字符串字面量|
|`__LINE__`|表示当前源代码文件中行号的整型常量|
|`__STDC__`|设置为 1 时，表明实现遵守 C 标准|
|`__STDC_HOSTED__`|本机环境设置为 1；否则设置为 0|
|`__STDC_VERSION__`|支持 C99 标准，设置为 199901L；支持 C11 标准，设置为 201112L|
|`__TIME__`|翻译代码的时间，格式为 "hh:mm:ss"|

C99 标准提供一个名为 `__fun__` 的预定义标识符，它展开为一个代表函数名的字符串（该函数包含该标识符）。那么，`__fun__` 必须具有函数作用域，
而从本质上看宏具有文件作用域。因此，`__fun__` 是C语言的预定义标识符，而不是预定义宏。

#### #line和#error
#line 指令重置 `__LINE__` 和 `__FILE__` 宏报告的行和文件名。
可以这样使用 #line：

`#line 1000` // 把当前行号重置为1000

`#line 10 "cool.c"` // 把行号重置为10，把文件名重置为cool.c

#error 指令让预处理器发出一条错误信息，该消息包含指令中的文本。如果可能的话，编译过程应该中断。
可以这样使用 #error 指令：
```c
#if __STDC_VERSION__ != 201112L
#error Not C11
#endif
```

#### #pragma
#pragma 把编译器指令放入源代码中。例如，在开发 C99 时，标准被称为 C9X，可以使用下面的编译指示（pragma）让编译器支持 C9X：
`#pragma c9x on`

一般而言，编译器都有自己的编译指示集。C99 标准提供了 3 个标准编译指示，不在这里讨论。
- 可用于控制分配给自动变量的内存量；
- 设置错误检查的严格程度；
- 启用非标准语言特性

C99 还提供 _Pragma 预处理器运算符，该运算符把字符串转换成普通的编译指示。例如：
`_Pragma("nonstandardtreatmenttypeB on")` 等价于 `#pragma nonstandardtreatmenttypeB on`

#### 泛型选择（C11）
泛型编程（generic programming）指那些没有特定类型，但是一旦指定一种类型，就可以转换成指定类型的代码。
C11新增了一种表达式，叫作泛型选择表达式（generic selection expression），可根据表达式的类型（即表达式的类型是int、double 还是其它类型）选择一个值。
泛型选择表达式不是预处理器指令，但是在一些泛型编程中它常用作#define宏定义的一部分。

示例：

`_Generic(x, int: 0, float: 1, double: 2, default: 3)`

`_Generic` 是 C11 的关键字。`_Generic` 后面的圆括号中包含多个逗号分隔的项。

第1个项是一个表达式，后面的每个项都由一个类型、一个冒号和一个值组成，如 float:1 。
第1个项的类型匹配哪个标签，整个表达式的值是该标签后面的值。

例如，假设上面表达式中x是int类型的变量，x的类型匹配 `int:` 标签，那么整个表达式的值就是0 。
如果没有与类型匹配的标签，表达式的值就是 `default:` 标签后面的值。

泛型选择语句与switch语句类似，只是前者用表达式的类型匹配标签，而后者用表达式的值匹配标签。


### 16.7 内联函数（C99）

通常，函数调用都有一定的开销，因为函数的调用过程包括建立调用、传递参数、跳转到函数代码并返回。
使用宏使代码内联，可以避免这样的开销。C99 还提供另一种方法：内联函数（inline function）。
“把函数变成内联函数建议尽可能地调用该函数，其具体效果由实现定义”。因此，把函数变成内联函数，
编译器可能会用内联代码替换函数调用，并（或）执行一些其他的优化，但是也可能不起作用。

创建内联函数的定义由多种方法。标准规定具有内部链接的函数可以称为内联函数，还规定了内联函数的定义与调用该函数的代码必须在同一个文件中。
因此，最简单的方法是使用函数说明符 `inline` 和存储类别说明符 `static` 。通常，内联函数应定义在首次使用它的文件中，所以内联函数也相当于函数原型。

如果程序多个文件都要使用某个内联函数，那么这些文件中都必须包含该内联函数的定义。简单做法，把内联函数定义放入头文件，使用的文件包含该头文件即可。

### 16.8 _Noreturn函数（C11）
C99 新增 inline 关键字时，它是唯一的函数说明符（关键字 extern 和 static 是存储类别说明符，可应用于数据对象和函数）。
C11 新增了第2个函数说明符 `_Noreturn` ，表明调用完成后函数不返回主调函数。exit() 函数是 `_Noreturn` 函数的一个示例，
一旦调用exit()，它不会再返回主调函数。void类型的函数在执行完毕后返回主调函数，只是它不提供返回值。

`_Noreturn`的目的是告诉用户和编译器，这个特殊的函数不会把控制返回
主调程序。告诉用户以免滥用该函数，通知编译器可优化一些代码。

### 16.9 C库

#### 访问C库
1.自动访问

在使用函数之前必须先声明函数的类型，通过包含合适的头文件。在一些系统中，只需编译程序，就可使用一些常用的库函数。

2.文件包含

如果函数被定义为宏，那么可以通过#include指令包含定义宏函数的文件。通常，类似的宏都放在合适名称的头文件中。

3.库包含

在编译或链接程序的某些阶段，可能需要指定库选项。即使在自动检查标准库的系统中，也会有不常用的函数库。必须通过编译时选项显示指定这些库。

#### 使用库描述
ANSI C把指向void的指针作为一种通用指针，用于指针指向不同类型的情况。假设实际参数是一个指向内含10个double类型元素的指针。
且形式参数是指向void的指针，那么编译器会选用合适的类型，不会出现类型冲突的问题。

### 16.10 数学库
数学库中包含许多有用的数学函数。`math.h` 头文件提供这些函数的原型。

#### 1.三角问题
- [把直角坐标转换为极坐标](rect_pol.c)

#### 类型变体
基本的浮点型数学函数接受 `double` 类型的参数，并返回 `double` 类型的值。也可以把 float 或 `long double` 类型的参数传递给这些函数，
它们仍然能正常工作，这些类型的参数会被转换成 `double` 类型，但并不是最好的处理方式。

如果不需要双精度，那么 `float` 类型的单精度值来计算会更快些。
而且把 `long double` 类型的值传递给 `double` 类型的形参会损失精度，形参获得的值可能不是原来的值。

为了解决这些潜在的问题，C标准专门为 `float` 类型和 `long double` 类型提供了标准函数，即在原函数名前加上 `f` 或 `l` 前缀。
因此，`sprtf()` 是 `sqrt()` 的 `float` 版本，`sqrtl()` 是 `sqrt()` 的 `long double` 版本。

利用 C11 新增的泛型选择表达式定义一个泛型宏，根据参数类型选择最合适的数学函数版本。

[定义泛型宏](generic.c)

#### tgmath.h库（C99）
C99标准提供的tgmath.h头文件中定义了泛型类型宏。如果编译器支持复数运算，就会支持complex.h头文件，声明了与复数运算相关的函数。
如果包含了tgmath.h，要调用sqrt()函数而不是sqrt()宏，可以用圆括号把被调用的函数名括起来：
```c
#include <tgmath.h>
...
float x=44.0;
y = sqrt(x); // 调用宏，所以是 sqrtf(x)
y = (sqrt)(x); // 调用函数 sqrt()
```
因为类函数宏的名称必须用圆括号括起来。圆括号只会影响操作顺序，不会影响括起来的表达式，所以仍然是函数调用的结果。
实际上，由于C语言奇怪而矛盾的函数指针规则，还可以使用(*sqrt)()的形式来调用sqrt()函数。

不借助C标准以外的机制，C11新增的 _Generic 表达式是实现 tgmath.h 最简单的方式。


### 16.11 通用工具库
通用工具库包含各种函数，包括随机数生成器、查找和排序函数、转换函数和内存管理函数。

#### exit()和atexit()函数
`atexit()`注册函数列表中的函数，当调用`exit()`时就会执行这些函数。ANSI保证，在这个列表中至少可以放 32 个函数。最后注册的函数最先执行。
注册的函数应该不带任何参数且返回类型为void。通常，这些函数会执行一些清理任务，例如更新监视程序的文件或重置环境变量。

`exit()`函数执行完`atexit()`指定的函数后，会完成一些清理工作：刷新所有输出流、关闭所有打开的流和关闭由标准I/O函数tmpfile()创建的临时文件。
然后`exit()`把控制权返回主机环境，如果可能的话，向主机环境报告终止状态。通常，UNIX使用0表示成功终止，用非零值表示终止时报。
ANSI C为了可移植，定义了 `EXIT_FAILURE` 的宏表示终止失败， `EXIT_SUCCESS` 表示成功终止。

#### qsort()函数 快速排序
- [快速排序](qsorter.c)

为了让该方法具有通用性，qsort()和比较函数使用了指向 void 的指针。因此，必须把数组中每个元素的大小明确告诉qsort()，
并且在比较函数的定义中，必须把该函数的指针参数转换为具体应用而言类型正确的指针。

__注意C和C++中的void*__

C和C++对待指向 void 的指针有所不同。两种语言，都可以把任何类型的指针赋给void类型的指针。例如，qsort()的函数调用中把 `double*` 指针赋给 `void*` 指针。
但是C++要求把 `void*` 指针赋值给任何类型的指针时必须强制进行类型转换。而C没有这样的要求。


### 16.12 断言库
`assert.h` 头文件支持的断言库是一个用于辅助调试程序的小型库。它由 `assert()` 宏组成，接受一个整型表达式作为参数。
如果表达式求值为假（非零），`assert()` 宏就在标准错误流（stderr）中写入一条错误信息，并调用 `abort()` 函数终止程序（`abort()` 函数的原型在 `stdlib.h` 头文件中）。

### 16.13 string.h库中的memcpy()和memmove()

不能把一个数组赋给另一个数组，所以要通过循环把数组中的每个元素赋给另一个数组相应的元素。

有一个例外情况是：使用strcpy() 和 strncpy() 函数来处理字符数组。

以下函数提供类似的方法处理任意类型的数组：
```
// 数带关键字restrict，即memcpy()假设两个内存区域之间没有重叠，如果出现重叠，行为是未定义的
void *memcpy(void * restrict s1, const void * restrict s2, size_t n);

// 先把所有字节拷贝到临时缓冲区，然后再拷贝到最终目的地
void *memmove(void *s1, const void *s2, size_t n);
```
这两个函数都从 s2 指向的位置拷贝 n 字节到 s1 指向的位置，而且都返回 s1 的值。

### 16.14 可变参数：stdarg.sh
宏可以接受可变数量的参数。stdarg.h 头文件为函数提供了一个类似的功能，但是用法比较复杂。必须按如下步骤进行：
1. 提供一个使用省略号的函数原型；
2. 在函数定义中创建一个 va_list 类型的变量；
3. 用宏把该变量初始化为一个参数列表；
4. 用宏访问参数列表；
5. 用宏完成清理工作。

### 16.15 关键概念
C标准不仅描述C语言，还描述了组成C语言的软件包、C预处理器和C标准库。通过预处理器可以控制编译过程、列出要替换的内容、指明要编译的代码行和影响编译器其他方面的行为。
C库扩展了C语言的作用范围，为许多编程问题提供现成的解决方案。

### 16.16 本章小结
C预处理器和C库是C语言的两个重要的附件。C预处理遵守预处理器指令，在编译源代码之前调整源代码。C库提供许多有助于完成各种任务的函数，包括输入、输出、文件处理、内存管理、排序和搜索、数学运算、字符串处理等。可参考完整的ANSI C库。
