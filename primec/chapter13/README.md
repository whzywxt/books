## 第13章 文件输入/输出

文件模式和二进制模式、文本和二进制格式、缓冲和无缓冲I/O

既可以顺序访问文件也可以随机访问文件

### 13.1 与文件进行通信
文件（file）通常是在磁盘或固态硬盘上的一段已命名的存储区。

所有文件的内容都是以二进制形式（0或1）存储。但是文件最初使用二进制编码的字符（如 ASCII或Unicode）表示文本（像C字符串那样），该文件就是文本文件，其中包含文本内容。如果文件中的二进制值代表机器语言代码或数值数据（使用相同的内部表示，假设，用于 long 或 double 类型的值）或图片或音乐编码，该文件就是二进制文件，其中包含二进制内容。

C 提供两种访问文件的途径：二进制模式和文本模式。在二进制模式中，程序可以访问文件的每个字节。而在文本模式中，程序所见的内容和文件的实际内容不同。程序以文本模式读取文件时，把本地环境表示的行末尾或文件结尾映射为 C 模式。

底层I/O使用操作系统提供的基本I/O服务。标准高级I/O使用C库的标准包和stdio.h头文件定义。

C标准只支持标准I/O包。C程序会自动打开3个文件，称为标准输入、标准输出和标准错误输出。

### 13.2 标准 I/O
与底层I/O相比，标准I/O两个好处。

第一，标准I/O有许多专门的函数简化了处理不同I/O的问题。例如，printf() 把不同形式的数据转换成与终端相适应的字符串输出。

第二，输入和输出都是缓冲的。一次转移一大块而不是一字节信息（通常至少512字节）。例如，当程序读取文件时，一块数据被拷贝到缓冲区（一块中介存储区域）。

新的C11新增了带x字母的写模式，比以前有更多特性。

第一，以传统的一种写模式打开一个现有文件，fopen() 会把该文件的长度截为0，这样就丢失了该文件的内容。但是使用带x字母的写模式，即使fopen()操作失败，原文件的内容也不会被删除。

第二，如果环境允许，x模式的独占特性使得其他程序或线程无法访问正在被打开的文件。

文件指针（fp）的类型是指向FILE的指针，FILE是一个定义在stdio.h中的派生类型。文件指针fp并不指向实际的文件，它指向一个包含文件信息的数据对象，其中包含操作文件的I/O函数所用的缓冲区信息。
标准I/O函数使用缓冲区，它们不仅要知道缓冲区的位置，还要知道缓冲区被填充的程度以及操作哪一个文件。标准I/O函数根据这些信息在必要时决定再次填充或清空缓冲区。

`fclose(fp)` 函数关闭 fp 指定的文件，必要时刷新缓冲区。对于较正式的程序，应该检查是否成功关闭文件。成功关闭，`fclose()` 函数返回0。如果磁盘已满、移动硬盘被移除或出现I/O错误，都会导致调用`fclose()` 函数失败。

|标准文件|文件指针|通常使用的设备|
|----|----|----|
|标准输入|stdin |键盘|
|标准输出|stdout|显示器|
|标准错误|stderr|显示器|

### 13.3 一个简单的文件压缩程序

### 13.4 文件 I/O
`fprintf()`、`fscanf()`、`fgets()`、`fputs()`

### 13.5 随机访问
`fseek()` 和 `ftell()`

### 13.6 标准 I/O 的机理

### 13.7 其他标准 I/O 函数
- `int ungetc(int c, FILE *fp)` 把 c 指定的字符放回输入流中。如果把一个字符放回输入流，下次调用标准输入函数时将读取该字符。
- `int fflush(FILE *fp)` 引起输出缓冲区中所有的未写入数据被发送到 fp 指定的输出文件。过程称为刷新缓冲区。如果 fp 是空指针，所有输出缓冲区都被刷新。在输入流中使用 fflush() 函数的效果是未定义的。只要最近一次操作不是输入操作，就可以用该函数来更新流（任意读写模式）。
- `int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size)` 创建了一个供标准I/O函数替换使用的缓冲区。在打开文件后且未对流进行其他操作之前，调用该函数。指针 fp 识别待处理的流，buf 指向待使用的存储区。如果 buf 的值不是 NULL，则必须创建一个缓冲区。
- `fread()` `fwrite()` 二进制I/O
- `size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb,FILE * restrict fp)` 把二进制数据写入文件。 指针 ptr 是待写入数据块的数量。size 表示待写入数据块的大小（字节单位），nmemb 表示待写入数据块的数量。fp 指定待写入的文件。
- `size_t fread(void * restrict ptr, size_t size, size_t nmemb,FILE * restrict fp)` 读取被 fwrite() 写入文件的数据。
- `int feof(FILE *fp)` `int ferror(FILE *fp)` 标准输入函数返回 EOF，通常表明函数已到达文件结尾。当上一次输入调用检测到文件结尾时，feof() 函数返回一个非零值，否则返回0。当读或写出现错误，ferror() 函数返回一个非零值，否则返回0。

### 13.8 关键概念
C 程序把输入看作是字节流，输入流来源于文件、输入设备（如键盘），或者甚至是另一个程序的输出。
C 程序把输出也看作是字节流，输出流的目的地可以是文件、视频显示等。

C 如何解释输入流或输出流取决于所使用的输入/输出函数。
程序可以不做任何改动地读取和存储字节，或者把字节依次解释成字符，随后可以把这些字符解释成普通文本以用文本表示数字。

要访问文件，必须创建文件指针（类型是 FILE *）并把指针与特定文件名关联。随后代码就可以使用这个指针（而不是文件名）来处理该文件。

C 如何处理文件结尾。通常，用于读取文件的程序使用一个循环读取输入，直至到达文件结尾。C 输入函数在读过文件结尾后才会检测到文件结尾，应该在尝试读取之后立即判断是否是文件结尾。

### 13.9 小结
大多数C程序，写入文件和读取文件必不可少。绝大多数C实现都提供底层I/O和标准高级I/O。ANSI C库考虑到可移植性，包含了标准I/O，但是未提供底层I/O。

标准I/O包自动创建输入和输出缓冲区以加快数据传输。

ANSI C提供两种文件打开模式：二进制和文本。以二进制模式打开文件时，可以逐字节读取文件；以文本模式打开文件时，会把文件内容从文本的系统表示法映射为C表示法。