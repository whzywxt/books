## 第14章 结构和其他数据形式
关键字：`struct`、`union`、`typedef`

运算符：`.`、`->`

创建结构模板和结构变量，访问结构的成员，编写处理结构的函数，联合和指向函数的指针


### 14.1 示例问题:创建图数目录
略

### 14.2 建立结构声明
略

### 14.3 定义结构变量
略

### 14.4 结构数组
略

### 14.5 嵌套结构
略

### 14.6 指向结构的指针
第一，指向数组的指针比数组本身更容易操控一样，指向结构的指针通常比结构本身更容易操控。

第二，一些早期的C实现中，结构不能作为参数传递给函数，但是可以传递指向结构的指针。

第三，即使能传递一个结构，传递指针通常更有效率。

第四，一些用于表示数据的结构中包含指向其他结构的指针。

### 14.7 向函数传递结构的信息
现在的C允许把一个结构赋值给另一个结构，但是数组不能这样做。如果n_data和o_data都是相同类型的结构，可以这样做赋值：`o_data = n_data;`

现在的C（包括ANSI C），函数不仅能把结构本身作为参数传递，还能把结构作为返回值返回。

把指针作为参数有两个优点：

无论是以前还是现在的C实现都能使用这种方法，而且执行起来很快，只需要传递一个地址。
缺点是无法保护数据。被调函数中的某些操作可能会意外影响原来结构中的数据。不过可以使用新增的const限定符来解决。

把结构作为参数传递的优点：
函数处理的是原始数据的副本，保护了原始数据。另外代码风格也更清楚。

两个缺点：较老版本的实现可能无法处理这样的代码，而且传递结构浪费时间和存储空间。尤其是把大型结构传递给函数，而它只使用结构中的一两个成员时特别浪费。这种情况下传递指针或只传递函数所需的成员更合理。

要用结构储存字符串，用字符数组作为成员比较简单。用指向char的指针也行，但是误用会导致严重的问题。**因为未经初始化的变量，地址可以是任何值。**

#### 复合字面量和结构（C99）
C99 的复合字面量特性可用于结构和数组。如果只需要一个临时结构值，复合字面量很好用。

例如，可以使用复合字面量创建一个数组作为函数的参数或赋给另一个结构。

语法是把类型名放在圆括号中，后面紧跟一个用花括号括起来的初始化列表。

例如，struct book 类型的复合字面量：

`(struct book){"The Idiot","Fyodor Dostoyevsky","6.99"}`

**复合字面量在所有函数的外部，具有静态存储期；如果复合字面量在块中，则具有自动存储期。复合字面量和普通初始化列表的语法规则相同。意味着，可以在复合字面量中使用指定初始化器。**

#### 伸缩型数组成员（C99）(flexible array member)
其最后一个数组成员具有一些特性。
- 特性一，该数组不会立即存在。
- 特性二，使用这个伸缩型数组成员可以编写合适的代码，好像它确实存在并具有所需数目的元素一样。

声明一个伸缩型数组成员有如下规则：
- 伸缩型数组成员必须是结构的最后一个成员；
- 结构中必须至少有一个成员；
- 伸缩数组的声明类似于普通数组，只是它的方括号中是空的。

C99 的意图并不是让你声明 struct flex 类型的变量，而是希望你声明一个指向 struct flex 类型的指针，然后用 malloc() 来分配足够的空间，以存储 struct flex 类型结构的常规内容和伸缩型数组成员所需的额外空间。

带伸缩型数组成员的结构确实有一些特殊的处理要求。

第一，不能用结构进行赋值或拷贝：
```
struct flex *pf1, *pf2;
...
*pf2 = *pf1; // 不要这样做
```
这样做只能拷贝除伸缩型数组成员以外的其他成员。确实要进行拷贝，应使用 `memcpy()` 函数。

第二，不要以按值方式把这种结构传递给结构，原因相同，按值传递一个参数与赋值类似。要把结构的地址传递给函数。

第三，不要使用带伸缩型数组成员的结构作为数组成员或另一个结构的成员。

struct hack，在结构中最后一个成员是伸缩型数组的情况。除了伸缩型数组成员在声明时使用空的方括号外，struct hack 特指大小为 0 的数组。struct hack 是针对特殊编译器（gcc）的，不属于C标准。这种方法是标准认可的编程技巧。

### 14.8 把结构内容保存到文件中
> 由于结构可以存储不同类型的信息，所以它是构建数据库的重要工具。例如，可以用一个结构存储雇员或汽车零件的相关信息。最终，我们要把这些信息存储在文件中，并且能再次检索。数据库文件可以包含任意数量的此类数据对象。储存在一个结构中的整套信息被称为记录（record），单独的项被称为字段（field）。

以二进制表示法存储数据的缺点是，不同的系统可能使用不同的二进制表示法，所以数据文件可能不具可移植性。甚至同一个系统，不同编译器设置也可能导致不同的二进制布局。


### 14.9 链式结构
结构的多种用途之一：创建新的数据形式。一些数据形式比我们提到过的数组和简单结构更有效地解决特定的问题。

形式包括队列、二叉树、堆、哈希表和图标。许多这样的形式都由链式结构（linked structure）组成。

通常，每个结构都包含一两个数据项和一两个指向其他同类型结构的指针。这些指针把一个结构和另一个结构链接起来，并提供一种路径能遍历整个彼此链接的结构。

考虑一个有10级节点的树的情况。它有2^10-1（或1023）个节点，可以存储1023个单词。

### 14.10 联合简介
> 联合（union）是一种数据类型，它能在同一个内存空间中存储不同的数据类型（**不是同时存储**）。其典型的用法是，设计一种表以存储既无规律、事先也不知道顺序的混合类型。使用联合类型的数组，其中的联合都大小相等，每个联合可以存储各种数据类型。

创建联合和创建结构的方式相同，需要一个联合模板和联合变量。可以初始化联合。需要注意的是，联合只能存储一个值，这与结构不同。编译器分配足够的空间以便它能存储联合声明中占用最大字节的类型。
```
union hold {
    int digit;
    double bigfl;
    char letter;
}

union hold fit; // hold类型的联合变量
union hold save[10]; // 内含10个联合变量的数组
union hold *pu; // 指向hold类型联合变量的指针
```

#### 使用联合
```
fit.digit=23； // 把23存储在fit，占2字节
fit.bigfl=2.0；// 清除23，存储2.0，占8字节
fit.letter='h'; // 清除2.0，存储h，占1字节
```

点运算符表示正在使用哪种数据类型。在联合中，一次只存储一个只。即使有足够的空间，也不能同时存储一个char类型值和一个int类型值。编写代码时要注意当前储存在联合中的数据类型。

和用指针访问结构使用`->`运算符一样，用指针访问联合时也要使用`->`运算符：
```
pu=&fit;
x=pu->digit; // 相当于 x=fit.digit
```

不过，用一个成员把值储存在一个联合中，然后用另一个成员查看内容，这种做法有时很有用。

联合的另一种用法是，在结构中储存与其成员有从属关系的信息。
```
struct owner
{
    char socsecurity[12];
    ...
};
struct leasecompany
{
    char name[40];
    char headquarters[40];
    ...
};
union data
{
    struct owner owncar;
    struct leasecompany leasecar;
};
struct car_data
{
    char make[15];
    int status; /* 私有为0，租赁为1 */
    union data ownerinfo;
    ...
};
```
假设flits是car_data类型的结构变量，
如果 `flits.status` 为0，程序将使用 `flits.ownerinfo.owncar.socsecurity`，
如果 `flits.status` 为1，程序则使用 `flits.ownerinfo.leasecar.name`。

#### 匿名联合（C11）
匿名联合和匿名结构的工作原理相同，即匿名联合是一个结构或联合的无名联合成员。

```
struct owner
{
    char socsecurity[12];
    ...
};
struct leasecompany
{
    char name[40];
    char headquarters[40];
    ...
};
union data
{
    struct owner owncar;
    struct leasecompany leasecar;
};
struct car_data
{
    char make[15];
    int status; /* 私有为0，租赁为1 */
    union
    {
        struct owner owncar;
        struct leasecompany leasecar;
    };
    ...
};
```
现在，如果 flits 是 car_data 类型的结构变量，可以用
`flits.owncar.socsecurity` 代替 `flits.ownerinfo.owncar.socsecurity`。

总结：结构和联合运算符
成员运算符：`.` 该运算符与结构或联合名一起使用，指定结构或联合的一个成员。
间接成员运算符：`->` 该运算符和指向结构或联合的指针一起使用，标识结构或联合的一个成员。

### 14.11 枚举类型
可以用枚举类型声明符号名称来标识整型常量。使用 enum 关键字，可以创建一个新“类型”并指定它可具有的值（实际上，enum 常量是 int 类型）。目的是提高程序的可读性。它的语法与结构的语法相同。

C枚举的一些特性并不适用于C++。例如，C允许枚举变量使用++运算符，但是C++标准不允许。

#### 常量
```
#include <stdio.h>

int main(int argc, char const *argv[])
{
    enum spectrum
    {
        red,
        orange,
        yellow,
        green,
        blue,
        violet
    };

    printf("red = %d, orange = %d\n", red, orange);
    return 0;
}
```
red = 0, orange = 1

red成为一个有名称的常量，代表整数0。

#### 默认值
默认情况下，枚举列表中的常量都被赋予0、1、2、...等。

#### 赋值
`enum levels {low=100, medium=500, high=2000};`

#### 共享名称空间
C语言使用名称空间（namespace）标识程序中的各部分，即通过名称来识别。作用域是名称空间概念的一部分：两个不同作用域的同名变量不冲突；两个相同作用域的同名变量冲突。

名称空间是分类别的。在特定作用域中的结构标记、联合标记和枚举标记都共享相同的命名空间，该名称空间与普通变量使用的空间不同。

这意味着在相同作用域中变量和标记的名称可以相同，不会引起冲突，但是不能在相同作用域中声明两个同名标签或同名变量。

例如，在C中，下面的代码不会产生冲突：
```
struct rect { double x; double y; };
int rect; // 在C中不会产生冲突
```

### 14.12 typedef简介
> typedef工具是一个高级数据特性，利用typedef可以为某一类型自定义名称。

与 #define 类似，但有3处不同：
- typedef创建的符号名只受限于类型，不能用于值。
- typedef由编译器解释，不是预处理器。
- 在其受限范围内，typedef比#define更灵活。

使用typedef的原因：
第一，为经常出现的类型创建一个方便、易识别的类型名。
```
typedef struct complex
{
    float real;
    float imag;
} COMPLEX;

typedef struct
{
    double x;
    double y;
} rect;

rect r1 = {3.0, 6.0};
rect r2;
r2 = r1; // 这两个结构在声明时都没有标记，它们的成员完全相同（成员名及其类型都匹配），C认为这两个结构的类型相同，所以r1和r2间的赋值是有效操作。
```
第二，用于给复杂的类型命名。
```
typedef char (* FRPTC ()) [5]; // 把FRPTC声明为一个函数类型，该函数返回一个指针，该指针指向内含5个char类型元素的数组
```

使用 typedef 时要记住，typedef 并没有创建任何新类型，它只是为某个已存在的类型增加了一个方便使用的标签。

### 14.13 其他复杂的声明
声明时可使用的符号
|符号|含义|
|----|----|
|*|表示一个指针|
|{}|表示一个函数|
|[]|表示一个数组|

### 14.14 函数和指针
通常，函数指针常用作另一个函数的参数，告诉该函数要使用哪一个函数。

函数也有地址，因为函数的机器语言实现由载入内存的代码组成。指向函数的指针中存储着函数代码的起始处的指针。

声明一个函数指针时，必须声明指针指向的函数类型。为了指明函数类型，要指明函数签名，即函数的返回类型和形参类型。例如，函数原型 `void (*pf)(char *); // pf是一个指向函数的指针`

### 14.15 关键概念
如果要在结构中增加一个成员，只需重写函数，不必改写函数调用。

联合声明于结构声明类似。但是，联合的成员共享相同的存储空间，而且在联合中同一时间内只能有一个成员。实质上，可以在联合变量中储存一个类型不唯一的值。

enum 工具提供一种定义符号常量的方法，typedef 工具提供一种为基本或派生类型创建新标识符的方法。

指向函数的指针提供一种告诉函数应使用哪一个函数的方法。

### 14.16 小结
C结构提供在相同的数据对象中储存不同类型数据项的方法。可以使用标记来标识一个具体的结构模板，并声明该类型的变量。通过成员点运算符（`.`）可以使用结构模板中的标签来访问结构的各个成员。

如果有一个指向结构的指针，可以用该指针和间接成员运算符（`->`）代替结构名和点运算符来访问结构的各成员。**和数组不同，结构名不是结构的地址**，要在结构名钱使用 `&` 运算符才能获得结构的地址。

一贯以来，与结构相关的函数都使用指向结构的指针作为参数。现在的 C 允许把结构作为参数传递，作为返回值和同类型结构之间赋值。然而，传递结构的地址通常更有效。

联合的成员共享一个共同的存储空间。联合同一时间内只能储存一个单独的数据项，不想结构那样同时储存多种数据类型。也就是说，结构可以同时储存一个int类型数据、一个double类型数据和一个char类型数据，而相应的联合只能保存一个int类型，或着一个double类型，或者一个char类型。

通过枚举可以创建一系列代表整型常量（枚举常量）的符号和定义相关联的枚举类型。

typedef工具可用于建立C标准类型的别名或缩写。

函数名代表函数的地址，可以把函数的地址作为参数传递给其他函数，然后这些函数就可以使用被指向的函数。如果把特定函数的地址赋给一个名为pf的指针，可以通过一下两种方式调用该函数。[代码](primec/chapter14/x.c)