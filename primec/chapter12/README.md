## 第12章 存储类别、链接和内存管理

### 12.1 存储类别

#### 作用域

#### 链接
C 变量有 3 种链接属性：外部链接、内部链接或无链接。

具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量。这些变量属于定义它们的块、函数或原型私有。

具有文件作用域的变量可以是外部链接或内部链接。外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用。

内部链接的文件作用域，称为文件作用域；如 `static int giants = 5;`
外部链接的文件作用域，称为全局作用域。如 `int giants = 5;`

#### 存储期
作用域和链接描述了标识符的可见性。
存储期描述了通过这些标识符访问的对象的生存期。
C 对象有 4 种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。
- 静态储存期，对象在程序执行期间一直存在。
- 线程存储期，用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明时到线程结束时一直存在。以关键字 `_Thread_local` 声明一个对象时，每个线程都获得该变量的私有备份。
- 自动存储期，程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放为变量分配的内存。
- 动态分配存储，变长数组，它们的存储期从声明处到块的末尾，而不是从块的开始处。

C 使用作用域、链接和存储期为变量定义了多种存储方案。

|存储类别|存储期|作用域|链接|声明方式|
|-------|-----|-----|---|------|
|自动|自动|块|无|块内|
|寄存器|自动|块|无|块内，使用关键字 register|
|静态外部链接|静态|文件|外部|所有函数外|
|静态内部链接|静态|文件|内部|所有函数外，使用关键字 static|
|静态无链接|静态|块|无|块内，使用关键字 static|

#### 自动变量
- 程序在进入该变量声明所在的块时变量存在，程序在退出该块时变量消失。原该变量占用的内存位置现在可做他用。
- 自动变量不会初始化，除非显示初始化它。

#### 寄存器变量
- 幸运的话，寄存器变量储存在CPU的寄存器中。
- 声明变量为 register 类别与直接命令相比更像是一种请求。编译器必须根据寄存器或最快可用内存的数量衡量你的请求，或者直接忽略你的请求，所以最终寄存器变量不一定存储的CPU的寄存器种。
- 可声明为 register 的数据类型有限。

#### 块作用域的静态变量
- 静态是该变量在内存中原地不动，值可以改变。
- 计算机在多次函数调用之间会记录它们的值。
- 只在编译时被初始化一次。
- 不能在函数的形参中使用 static。

#### 外部链接的静态变量
- 文件作用域、外部链接和静态存储期。
- 有时称为外部存储类别，属于该类别的变量称为外部变量。
- 为指出该函数使用了外部变量，可以在函数中用关键字 extern 再次申明。

#### 内部链接的静态变量
- 文件作用域、内部链接和静态存储期。

#### 存储类别说明符
- 关键字 static 和 extern 的含义取决于上下文
- 说明符 auto、register、static、extern、_Thread_local、typedef
- _Thread_local 可以和 static 或 extern 一起使用

#### 存储类别的选择
- 默认类别就是自动存储类别，其他存储类别也很有用，但需要考虑是否必要使用。
- 经验表明，随意使用外部存储类别的变量导致的后果远远超过了它所带来的便利。
- `const` 数据，初始化后就不会被修改，不用担心被意外修改。

保护性程序设计的黄金法则：“按需知道”原则。尽量在函数内部解决该函数的任务，只共享那些需要共享的变量。

### 随机数函数和静态变量
“种子”

### 分配内存
`malloc()` 与 `free()` 配套使用，free **不能释放**通过其他方式分配的内存。free 参数应该是一个指针。

静态数据在程序载入内存时分配，而自动数据在程序执行块时分配，并在离开该块时销毁。

创建数组的3种方法
- 用常量表达式表示数组的纬度，用数组名访问数组的元素。可以用静态内存或自动内存创建这种数组。
- 变长数组（C99新增特性）时，用变量表达式表示数组的维度，用数组名访问数组的元素。只能在自动内存中创建。
- 声明一个指针，调用malloc，将其返回值赋给指针，使用指针访问数组的元素。该指针可以式静态的或动态的。

静态内存的数量在编译时是固定的，在程序运行期间也不会改变。自动变量使用的内存数量在程序执行期间自动增加或减少。但是动态分配的内存数量只会增加，除非使用 free 进行释放。

分配内存 calloc 函数，还有一个特性：它把块中的所有位都设置为0（注意，在某些硬件系统中，不是把所有位都设置为 0 来表示浮点值 0）。free 函数也可用于释放 calloc 分配的内存。

#### 存储类别和动态内存分配
可以认为程序把内存分为 3 部分：
- 一部分供具有外部链接、内部链接和无链接的静态变量使用；
- 一部分供自动变量使用；
- 一部分供动态内存分配。

**静态存储类别**所用的内存数量在编译时确定，只要程序还在运行，就可以访问存储在该部分的数据。该类别的变量在程序开始执行时被创建，在程序结束时被销毁。

**自动存储类别**的变量在程序进入变量定义所在块时存在，在程序离开块时消失。随着程序调用函数和函数结束，自动变量所用的内存数量也相应地增加或减少。
这部分内存通常作为栈来处理，新创建的变量按顺序加入内存，然后以相反的顺序销毁。

**动态分配**的内存在调用 `malloc()` 或相关函数时存在，在调用 `free()` 后释放。这部分内存由程序员管理，而不是一套规则。内存可以在一个函数中创建，在另一个函数中销毁。所以这部分内存用于动态内存分配会支离破碎。未使用的内存块分散在已使用的内存块之间。使用动态内存通常比使用栈内存慢。

总之，程序把静态对象、自动对象和动态分配的对象存储在不同的区域。

### ANSI C 类型限定符

#### const类型限定符
以 const 关键字声明的对象，其值不能通过赋值或递增、递减来修改。

1.在指针和形参中声明中使用 const

指针使用时区分是限定指针本身为 const 还是限定指针指向的值为 const。

const 放在 * 左侧任意位置，限定了指针指向的数据不能改变；
const 放在 * 右侧，限定了指针本身不能改变。

2.对全局数据使用 const
使用全局变量有点冒险，因为暴露了数据，程序任何部分都能更改数据。设置为 const 很合理。

文件中共享 const 数据策略。
第一，遵循外部变量的常用规则，即在一个文件中使用定义式声明，在其他文件中使用引用式声明（用 extern 关键字）。
第二，把const变量放在一个头文件中，然后其他文件引入头文件。

#### volatile 类型限定符
volatile 限定符告知计算机，代理（而不是变量所在程序）可以改变该变量的值。通常，它被用于硬件地址以及在其它程序或同时运行的线程中共享数据。

例如，一个地址上可能存储着当前的时钟时间，无论程序做什么，地址上的值都随时间的变化而改变。或者一个地址用于接受另一台计算机传入的信息。

可以同时用 const 和 volatile 限定一个值。例如，通常用 const 把硬件时钟设置为程序不能更改的变量，但是可以通过代理改变，这时用 volatile。

在声明中同时使用这两个限定符，顺序不重要，如
```
volatile const int loc;
const volatile int *ploc;
```

#### restrict 类型限定符
restrict 关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。

restrict 关键字有两个读者。一个是编译器，该关键字告知编译器可以自由假定一些优化方案。
另一个是用户，该关键字告知用户要使用满足 restrict 要求的参数。

#### _Atomic 类型限定符（C11）
并发程序设计把程序执行分成可以同时执行的多个线程。C11 通过包含可选的头文件 `stdatomic.h` 和 `threads.h`，提供了一些可选的（不是必须实现的）管理方法。当一个线程对一个原子类型的对象执行原子操作时，其它线程不能访问该对象。

#### 旧关键字的新位置
C99 允许把类型限定符和存储类别说明符 static 放在函数原型和函数头的形式参数的初始方括号中。

对于类型限定符而言，为现有功能提供了一个替代的语法。

a1 是一个指向 int 的 const 指针，这意味着不能更改指针本身，可以更改指针指向的数据。a2 是一个 restrict 指针。
`void ofmouth(int * const a1, int * restrict a2, int n)`; // 旧风格
`void ofmouth(int a1[const], int a2[restrict], int n)`; // C 99允许

`double stick(double ar[static 20]);`
static 的这种用法表明，函数调用中的实际参数应该是一个指向数组首元素的指针，且该数组至少有 20 个元素。

### 小结
内存用于存储程序中的数据，由存储期、作用域和链接表征。

存储期可以是静态的、自动的或动态分配的。

静态存储期，在程序开始执行时分配内存，并在程序运行时都存在。

自动存储期，在程序进入变量定义所在块时分配变量的内存，在程序离开时释放内存。

动态分配存储期，在调用 malloc()（或相关函数）时分配内存，在调用 free() 函数时释放内存。


作用域决定程序的哪些部分可以访问某数据。

定义在所有函数之外的变量具有文件作用域，对位于该变量声明之后的所有函数可见。

定义在块或作为函数形参内的变量具有块作用域，只对该块以及它包含的嵌套块可见。


链接描述定义在程序某翻译单元中的变量可被链接的程度。

具有块作用域的变量是局部变量，无链接。

具有文件作用域的变量可以是内部链接或外部链接。

内部链接意味着只有其定义所在的文件才能使用该变量。

外部链接意味着其他文件使用也可以使用该变量。

---
C 的 5 种存储类别（不包括线程的概念）。

#### 1. 自动
在块中不带存储类别说明符或带 auto 存储类别说明符声明的变量（或作为函数头中的形参）属于自动存储类别，具有自动存储期、块作用域、无链接。如果未初始化自动变量，它的值是未定义的。

#### 2. 寄存器
在块中带 register 存储类别说明符声明的变量（或作为函数中的形参）属于寄存器存储类别，具有自动存储期、块作用域、无链接，且无法获取其地址。把一个变量声明为寄存器变量即请求编译器将其存储到访问速度最快的区域。如果未初始化寄存器变量，它的值是未定义的。

#### 3. 静态、无链接
在块中带 static 存储类别说明符声明的变量属于“静态、无链接”存储类别，具有静态存储期、块作用域、无链接。只在编译时被初始化一次。如果未显式初始化，它的字节都被设置为 0。

#### 4. 静态、外部链接
在所有函数外部且没有使用 static 存储类别说明符声明的变量属于“静态、外部链接”存储类别，具有静态存储期、文件作用域、外部链接。只能在编译器被初始化一次。如果未显式初始化，它的字节都被设置为 0。

#### 5. 静态、内部链接
在所有函数外部且使用了 static 存储类别说明符声明的变量属于“静态、内部链接”存储类别，具有静态存储期、文件作用域、内部链接。只能在编译器被初始化一次。如果未显式初始化，它的字节都被设置为 0。

---

动态分配的内存由 malloc()（或相关）函数分配，该函数返回一个指向指定字节数内存块的指针。这块内存被 free() 函数释放后便可重复使用，free() 函数以该内存块的地址作为参数。

---
类型限定符 const、volatile、restrict和_Atomic。
const 限定符限定数据在程序运行时不能改变。对指针使用 const 时，可限定指针本身不能改变或指针指向的数据不能改变，这取决于 const 在指针声明中的位置。

volatile 限定符表明，限定的数据除了被当前程序修改外还可以被其他进程修改。该限定符的目的是警告编译器不要进行假定的优化。

restrict 限定符也是为了方便编译器设置优化方案。restrict 限定的指针是访问它所指向数据的唯一途径。

