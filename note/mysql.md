> https://www.huaweicloud.com/articles/8bbe2422a90d0731de4daa9a6e0837db.html
> https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html
> https://blog.csdn.net/ThinkWon/article/details/104778621#_35

### 数据保存在内存
- 优点：存取速度快
- 缺点：数据不能永久保存

### 数据保存在文件
- 优点：数据永久保存
- 缺点：
    - 速度比内存操作慢，频繁的IO操作
    - 查询数据不方便

### 数据保存在数据库
- 数据永久保存
- 使用 SQL 语句，查询方便效率高
- 管理数据方便

## 什么是SQL
结构化查询语言（Structured Query Language）简称SQL，是一种数据库查询语言。

## 三大范式
第一范式：每个列都不可以再拆分。
第二范式：在第一范式基础上，非主键列完全依赖于主键，而不能是依赖主键的一部分。
第三范式：

## mysql 有关权限的表


## mysql 的 binlog 几种格式和区别
三种格式：
- `statement` 每一条会修改的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog的日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
- `row` 不记录sql语句上下文信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动，因此这种模式的文件保存的信息太多，日志量大。
- `mixed` 一种折中方案，普通操作使用 statement 记录，当无法使用 statement 时使用 row 。

## 数据类型
> 具体还是看官方手册，版本不同细节太多
- `decimal` 能存储精确小数，可以用于存储比 `bigint` 还大的整型
- `datetime` 
    - 存储范围 `1000-01-01 ~ 9999-12-31`
    - 与时区无关（就是存储时当前服务器的时区），数据是什么，就存储什么，也就返回什么。
    - 存储大小 `5.6.4` 版本之前 `datetime` 8个字节，之后非小数点部分5个字节，小数部分需要 0到3个字节，取决于小数秒精度
- `timestamp` 
    - 存储范围 `1970 ~ 2038` 超出范围会报错
    - 与时区有关（存储时转为UTC存储），查询时从UTC转换为当前时区进行返回。
    - 存储大小 `5.6.4` 版本之前 `timestamp` 4个字节，之后非小数点部分4个字节，小数部分需要 0到3个字节，取决于小数秒精度

### 字符串
varchar 可变长，使用额外1或2个字节存储字符长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。
char 定长，非常短的列可选 char 存储

## 引擎
- InnoDB：提供了对数据库ACID事务的支持，并且还提供了行级锁和外键的约束，设计目的是处理大数据容量的数据库系统。
- MyIASM：不提供事务的支持，也不支持行锁和外键。
- MEMORY：所有数据都在内存中，数据的处理速度快，但是安全性不高。

## 索引
- 主键索引：数据列不允许重复，不允许为null，一个表只能有一个主键。
- 唯一索引：数据列不允许重复，允许为null值，一个表允许多个列创建唯一索引（或者多列组合一个唯一索引）。
- 普通索引：基本的索引类型，没有唯一性的限制，允许为null值。
- 全文索引：是目前搜索引擎使用的一种关键技术。

### 索引的数据结构
- B+树索引，InnoDB 存储引擎默认索引实现。大部分场景，建议选择
- Hash索引，底层数据结构就是哈希表，绝大多数需求为单条记录查询的时候，可以选择该索引，查询性能快。

## 事务
事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位。事务逻辑上是一组操作，要么都执行，要么都不执行。

四大特性：
- 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。
- 一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。
- 隔离性：并发访问数据库时，一个用户的事务不被其它事务所干扰，各并发事务之间数据库是独立的。
- 持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 脏读、幻读、不可重复度
- 脏读：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个 rollback 操作，则后一个事务所读取的数据就会是不正确的。
- 不可重复度：在一个事务的两次查询之中数据不一致，可能是两次查询过程中间插入了一个事务更新的原有的数据。
- 幻读：在一个事务的两次查询中数据记录数不一致，例如有一个事务查询了几列数据，而另一个事务却在此时插入了新的几列数据，现在的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

### 事务隔离级别
- `READ-UNCOMMITTED` 读未提交，最低隔离级别，可能导致 脏读、幻读或不可重复读。
- `READ-COMMITTED` 读已提交，可阻止脏读，但是幻读或不可重复度仍可发生。
- `REPEATABLE-READ` 可重复读，对同一字段的多次读取结果都是一致的，除非数据被本身事务所修改，可以阻止脏读和不可重复读，但幻读仍可能发生。
- `SERIALIZABLE` 可串行化，最高隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，事务之间不干扰，该级别可以防止脏读、不可重复读以及幻读。

Mysql 默认采用的`可重复读`，事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是`MVVC（多版本并发控制）`，通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。

## 锁
数据库有并发事务时，可能产生数据不一致，需要锁机制来保证访问的次序。

隔离级别与锁的关系
- 在 `READ-UNCOMMITTED` 级别下，读取数据不加`共享锁`，即不会与被修改的数据上的`排他锁`冲突。
- 在 `READ-COMMITTED` 级别下，读操作加`共享锁`，执行完后释放。
- 在 `REPEATABLE-READ` 级别下，读操作加`共享锁`，但是在事务提交之前不释放，等事务提交后再释放。
- 在 `SERIALIZABLE` 级别下，锁定整个范围的数据，直到事务提交。

### 锁粒度
- MyISAM 引擎采用表级锁
- InnoDB 引擎支持行级锁和表级锁，默认为行级锁

**行级锁**，粒度最小，开销大，针对当前操作的行进行加锁。行级锁大大减少数据库操作的冲突。分为共享锁和排他锁。

特点：开销大，加锁慢；会出现死锁；锁冲突概率低，并发最高。

InnoDB使用行锁的前提条件是检索数据通过索引，不一定使用了索引检测就一定会使用行锁，也可能使用表锁，看MySQL的执行计划，当全表扫描比索引有效率更高时，会使用表锁。


**表级锁**，表共享锁和表独占锁。
特点：开销小，加锁快；不会出现死锁；锁粒度大，锁冲突概率高，并发度最低。


**页级锁**，介于行级锁和表锁之间，会出现死锁，并发度一般。（BDB引擎）

共享锁，又称读锁。读取数据时对数据加共享锁，可以同时加多个。

排他锁，又称写锁。写入数据时对数据加上排他锁。排他锁只可以加一个，与其它的排他锁、共享锁都相斥。

InnoDB锁的算法：
- `Record Lock`：单个行记录上的锁。
- `Gap Lock`：间隙锁，锁定一个范围，不包括记录本身。
- `Next-Key Lock`：`Record + Gap` 锁定一个范围，包含记录本身。

相关点：
- InnoDB对于行的查询使用 `Next-Key Lock`
- `Next-Key Lock` 为了解决幻读
- 查询索引有唯一属性，`Next-Key Lock` 降级为 `Record Lock`
- 显示关闭 `Gap Lock`，将事务隔离级别设置为 `RC`，将参数 `innodb_locks_unsafe_for_binlog` 设置为 1 。

### 死锁和解决方法
死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

常见解决方法：
1. 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
2. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生的概率。
3. 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。

如果业务处理不好可以用分布式事务锁或者使用乐观锁。

### 乐观锁和悲观锁
并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。
乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

悲观锁：假定会发生并发冲突，屏蔽一切可能违反完整性的操作。使用数据中的锁机制。（多写场景，一般会产生冲突，上层应用不断进行尝试，降低了性能，所有用悲观锁比较合适。）

乐观锁：假设不会发生冲突，只在提交操作时检查是否违反数据完整性。在修改数据时把事务锁起来，通过version方式锁定。
实现方式，一般使用版本号机制或CAS算法。（多读场景，冲突很少会发生，省去锁开销，加大系统吞吐量。）

CAS缺点：
- 循环时间长
- 只能保证一个共享变量原子操作
- 会出现ABA问题

## 游标
游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果。

## 存储过程与函数
存储过程是一个预编译的SQL语句，优点是允许模块化的设计，一次创建，多次调用。

优点：
- 预编译过的，执行效率高。
- 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
- 安全性高，需要权限。
- 可重复使用，减少开发工作量。

缺点：
- 调试麻烦
- 移植问题
- 重新编译问题，引用关系对象发生改变时，受影响的存储过程、包将需要重新编译
- 不好维护，需求变更会导致数据结构变化

## 触发器
用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。

使用场景：
- 监控表中某个字段的更改而需要做出相应的处理

不要滥用，否则会造成数据库及应用程序的维护困难。

### 6种触发器
- `before`、`after` INSERT
- `before`、`after` UPDATE
- `before`、`after` DELETE

## 关联查询
- 交叉连接（cross join）
- 内连接（inner join）
    - 等值连接： `ON a.id = b.id`
    - 不等值连接： `ON a.id > b.id`
    - 自连接
- 外连接（left join / right join）
    - 左外连接： `LEFT OUTER JOIN`，以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用 `NULL` 填充，可以写成 `LEFT JOIN`
- 联合查询（union 和 union all）
    - union 把多个结果集集中在一起，注意联合查询的列数要相等，相同的记录行会合并
    - union all 不会合并重复的记录行，效率相对要高
- 全连接（full join）
    - mysql 不支持全连接
    - 可以使用 `LEFT JOIN` 和 `UNION` 和 `RIGHT JOIN` 联合使用，`SELECT * FROM A LEFT JOIN B ON A.id=B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id=B.id`

### IN 和 EXISTS 区别
子查询三种情况：
- 单行单列：父查询使用 <、>、= 等运算符
- 多行多列：父查询使用 IN 运算符
- 多行多列：类似一张虚拟表

IN 语句是把外表和内表作 hash 连接，而 exists 语句是对外表作 loop 循环，每次 loop 循环再对内表进行查询。

两者效率：
- 查询的两个表大小相当，用 in 或 exists 差别不大
- 两个表中一个较小，一个较大，则子查询表大的用 exists ，子查询表小的用 in。
- not in 和 not exists，如果查询语句用了 not in，那么内外表都要进行全表扫描，每用到索引；而 not exists 的子查询仍然能用到表上的索引。

## DROP、DELETE 与 TRUNCATE 的区别
|  | DELETE  |  TRUNCATE   | DROP  |
|  :----:  | :----:  |  :----:  | :----:  |
| 类型  | 属于DML |属于DDL  | 属于DDL |
| 回滚  | Y | N | N |
| 删除内容  | 表结构还在，删除表的全部或一部分数据行 | 表结构还在，删除表中的全部数据  | 从数据库中删除表，所有的数据行、索引和权限也被删除 |
| 删除速度  | 慢，需逐行删除 | 快  | 最快 |

## SQL 优化
至少达到 range 级别，要求是 ref 级别，const 最好。
- const 单表中最多只有一个匹配行（主键或唯一索引）
- ref 使用普通的索引
- range 索引范围检索

大表数据查询优化
- 优化 shema、sql 语句索引
- 应用层缓存，如：redis
- 主从复制，读写分离
- 垂直拆分，将大的系统分为多个小系统
- 水平拆分，合理的 sharding key，然后将数据定位到限定的表上去查

超大分页
- 数据库层面，尽量减少load的数据，如：拿到大分页的起始主键id值
- 需求层面，减少直接跳转的，只能逐页查看或按照给定的路线

## 慢查询日志
配置项：`slow_query_log`、`long_query_time`

实际操作应该从长时间设置到短的事件，将慢SQL优化掉。

```
show variables like 'slow_query_log';
show variables like 'long_query_time';
```

习惯可以在测试库上测试其耗时，慢查询的统计由DBA或运维定期反馈。

优化方向：
- 分析语句，看是否load额外的数据，或加载了不需要的列；
- 分析执行计划，看索引使用情况，尽可能命中索引和小的扫描行数；
- 最后考虑表中的数据量是否太大，如果是可以进行横向或纵向分表。
- 优化查询过程中的数据访问
    - 尽量只返回需要的行和列、字段
    - 使用 limit 返回指定行数数据
    - 改变数据库和表的结构，修改数据表范式
    - 重写sql，让优化器以更优的方式执行查询
- 优化长难的查询语句
    - 合适的情况，将一个大查询分解为多个小的查询很有必要
    - 分解关联查询，让缓存效率变高
    - 较少冗余记录的查询
- 优化关联查询
    - 确定ON或USING子句中是否由索引
    - 确保group by和order by只有表中的一个列，才有可能使用索引
- 优化子查询
    - 用关联查询替代
- 优化 WHERE
    - 尽量不要在where子句中的 `=` 左边进行函数、算术运算或其它表达式运算，否则系统可能无法使用索引

尽量为表设置一个主键，推荐自增id，聚簇索引。

字段尽量定义为 NOT NULL，不仅仅是NULL值会占用更多的字节，而且可能造成一些预期不符的情况。

固定长度的字符，如身份证号、密码散列，盐可使用char，节省空间并提到检索效率。

## 数据库优化
系统的吞吐量瓶颈往往出现在数据库的访问速度上。数据在磁盘上，读写速度无法和内存相比。

结构优化：
- 考虑数据冗余、字段的数据类型。
- 将字段很多的表分解成多个表，如，将某些字段使用频率很低，可将这些字段分离出来形成新表。
- 需经常联合查询的表，考虑建立中间表。

cpu飙升500%
- top 命令看是不是mysql占用导致
- show processlist


## MySQL 的复制原理及流程
将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。

主从复制作用：
- 主库出现问题，切换到从库
- 数据库层面读写分离
- 在从数据上进行日常备份

解决问题：
- 数据分布：随意开始或停止复制，并在不同地理位置分布数据备份
- 负载均衡：降低单台服务器压力
- 高可用和故障切换：帮助应用程序避免单点失败
- 升级测试：可以使用更高版本的Mysql作为从库

工作原理：
- 在主库上把数据更新和新增记录到二进制日志
- 从库将主库的日志复制到自己的中继日志
- 从库读取中继日志的事件，将其重放到从数据库中

3个线程之间的关联
- 主：binlog 线程，记录所有改变了数据库数据的语句，放进 master 的 binlog（主数据的二进制日志）中；
- 从：io 线程，在使用 `start slave` 之后，负责从master上拉取binlog内容，放进自己的 relay log（从服务器的中继日志）中；
- 从：sql Thread 执行线程，按顺序执行 relay log 中的语句，从而数据保持一致。
