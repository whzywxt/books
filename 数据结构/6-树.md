## 树

> 树（Tree）是 n （n>=0）个结点的有限集。n=0 时称为空树。在任意一棵非空树中：
>
> （1）有且仅有一个特定的称为根的结点
>
> （2）当 n>1 时，其余结点可分为 m（m>0）个互不相交的有限集 T1、T2、......、Tn，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。

#### 树的定义

###### 结点分类

树的结点包含一个数据元素及若干指向其子树的分支。**结点拥有的子树树称为结点的度。度为 0 的结点称为叶节点或终端结点；度不为 0 的结点称为 非终端结点或分支结点。除根节点之外，分支结点也称为内部结点。树的度是树内结点的度的最大值。**

###### 结点间的关系

**孩子**结点：结点的子树的根称为该结点的孩子（Child）；

**双亲**结点：孩子结点的双亲（Parent）；

**兄弟**结点：同一个双亲的孩子结点之间互称兄弟；

**祖先**结点：从根到该结点所经分支上的所有结点；

**子孙**结点：以某结点为根的子树中的任一结点都称为该结点的子孙；

###### 树的其它相关概念

结点的**层次**，从根开始定义起，根为第一层，根的孩子为第二层。

树中结点的最大层次称为树的**深度或高度**。

如果将树中结点的各子树看成从左到右是有次序的，不能互换的，则称该树为**有序树**，否则称为**无序树**。

###### 线性结构

- 第一个数据元素：无前驱
- 最后一个元素：无后继
- 中间元素：一个前驱一个后继

###### 树结构

- 根节点：无双亲，唯一
- 叶节点：无孩子，可以多个
- 中间结点：一个双亲多个孩子

#### 树的存储结构

表示法

- 双亲表示法
  - 在每个结点中，附设一个指示器指示其双亲结点到链表中的位置
- 孩子表示法
  - 每个结点有多个指针域，其中每个指针指向一棵子树的根结点，即**多重链表表示法**。
  - 方案一，指针域的个数就等于树的度，树的度是树各个结点度的最大值。适合树的各结点度相差比较小。
  - 方案二，每个结点指针域的个数等于该节点的度，专门取一个位置来存储结点指针域的个数。
  - 把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。
  - 双亲孩子表示法，可知道某个结点的双亲
- 孩子兄弟表示法

存储结构的设计是一个非常灵活的过程。一个存储结构设计的是否合理，取决于基于该存储结构的运算是否合适、是否方便，时间复杂度好不好等。

#### 二叉树

> 二叉树（Binary Tree）是 n（n>=0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

特点：

- 每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。没有子树或有一棵子树都是可以的。
- 左子树和右子树是有顺序的，次序不能任意颠倒。
- 即使树中某结点只有一棵子树，也要区分它是左子树，还是右子树。

形态：

- 空二叉树
- 只有一个根结点
- 根结点只有左子树
- 根结点只有右子树
- 根结点既有左子树又有右子树

###### 特殊二叉树

**斜树**，所有的结点都只有左子树的二叉树叫**左斜树**；所有结点都是只有右子树的二叉树叫**右斜树**。

**满二叉树**，在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上。

**满二叉树特点：**

- 叶子只能出现在最下一层，出现在其它层就不能达成平衡。
- 非叶子结点的度一定是 2，否则就是缺了。
- 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。

**完全二叉树**，对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1<=i<=n）的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，或者说示意图编号出现空挡，则这棵二叉树称为完全二叉树。

满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。

**完全二叉树特点：**

- 叶子结点只能出现在最下两层。
- 最下层的叶子一定集中在左部连续位置。
- 倒数二层，若有叶子结点，一定都在右部连续位置。
- 如果结点度为 1，则该结点只有左孩子，即不存在只有右子树的情况。
- 同样结点数的二叉树，完全二叉树的深度最小。

#### 二叉树的性质

性质1：在二叉树的第 i 层上至多有 2 <sup>i-1</sup>个结点（i >= 1）。

性质2：深度为 k 的二叉树至多有 2<sup>k</sup>-1个结点。

性质3：对任何一棵二叉树 T，如果其终端结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1。

- 终端结点数其实就是叶子结点数，除了叶子结点数外，剩下的就是度为 1 或 2 的结点数了，树 T结点总数 n = n<sub>0</sub> + n<sub>1</sub> + n<sub>2</sub>。

性质4：具有 n 个结点的完全二叉树的深度为 log<sub>2</sub>n + 1

性质5：如果对一棵有 n 个结点的完全二叉树的结点按层序编号，对任一结点 i 有：

1. 如果 i=1，则结点 i 是二叉树的根，无双亲；如果 i>1，则其双亲是结点 [i/2]。
2. 如果 2i > n，则结点 i 无左孩子（结点 i 为 叶子结点）；否则其左孩子是结点 2i。
3. 如果 2i+1 > n，则结点 i 无右孩子；否则其右孩子是结点 2i+1。

#### 二叉树的存储结构

###### 二叉树顺序存储结构

二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲和孩子结点的关系，左右兄弟结点的关系等。

顺序存储结构一般只用于完全二叉树。

###### 二叉链表

二叉树每个结点最多有两个孩子，所以设计一个数据域和两个指针域的链表，二叉链表。

- data - 数据域
- lchild - 指针域，指向左孩子
- rchild - 指针域，指向右孩子

如果需要，还可以再增加一个指向其双亲的指针域，称为三叉链表。

#### 遍历二叉树

###### 二叉树遍历原理

在有限时间内，要达到最高效率，次序非常重要。

**二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。**

###### 遍历方法

对于计算来说，它只有循环、判断等方式来处理，也就是说，只会处理线性序列。

**1.前序遍历**

规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子序，再前序遍历右子树。

如：ABDGHCEIF。

**2.中序遍历**

规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。

如：GDHBAEICF。

**3.后序遍历**

规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。

如：GHDBIEFCA。

**4.层序遍历**

规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。

如：ABCDEFGHI。

#### 线索二叉树

指向**前驱和后继的指针**称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树。

对二叉树以某种次序遍历使其变为线索二叉树的过程称为**线索化**。

#### 树、森林与二叉树的转换