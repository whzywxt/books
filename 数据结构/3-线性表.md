## 线性表

- 顺序存储结构
- 链式存储结构
  - 单链表
  - 静态链表
  - 循环链表
  - 双向链表


#### 线性表的链式存储

解决顺序存储结构不足

链表中第一个结点的存储位置叫做头指针，整个链表的存取就必须从头指针开始进行

###### 头指针
- 头指针是指链表指向第一个节点的指针，若链表有头结点，则是指向头结点的指针
- 头指针具有标识作用，所以常用头指针冠以链表的名字
- 无论链表是否为空，头指针均不能为空。头指针是链表的必要元素

###### 头结点
- 头结点是为了操作的统一和方便而设立的，放在第一元素的节点之前，其数据域一般无意义（也可存放链表的长度）
- 有了头结点，对在第一元素结点前掺入结点和删除第一结点，其操作与其它结点的操作就统一了
- 头结点不一定是链表必要元素

#### 单链表的读取
- 遍历
- O(n)

#### 单链表的插入与删除
对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。
- 遍历查找第 i 个元素
- 插入和删除元素

#### 单链表的整表创建
动态生成链表的过程，从“空表”的初始状态起，依次建立各元素结点，并逐个插入链表。

#### 单链表的整表删除
一个结点除了有数据域，还有指针域。free() 时，其实是在对它整个结点进行删除和内存释放的工作。

#### 单链表结构与顺序存储结构优缺点
###### 存储分配方式
- 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素
- 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素
###### 时间性能
- 查找
  - 顺序存储结构 O(1)
  - 单链表 O(n)
- 插入和删除
  - 顺序存储结构需要平均移动表长一半的元素，时间为 O(n)
  - 单链表在找出某位置的指针后，插入和删除时间仅为 O(1)
- 空间性能
  - 顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢
  - 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制
  
###### 选择
- 频繁查找，很少进行插入或删除操作时，宜采用顺序存储结构，反之，宜采用单链表结构。
- 线性表中元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题


#### 静态链表
用数组描述的链表叫做静态链表，游标实现法。用数组来代替指针，来描述链表。
其实为了给没有指针的高级语言设计的一种实现单链表能力的方法。

###### 优点
- 在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点

###### 缺点
- 没有解决连续分配带来的表长难以确定的问题
- 失去了顺序存储结构随机存取的特性


#### 循环链表
将单链表中终端节点的指针端由空指针改为指向头节点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称**循环链表**。

两个循环链表合并成一个表时，使用尾指针比较方便。


#### 双向链表
双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。

双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。

对于链表中的某一个结点 p，它的后继的前驱还是它自己。
```
p->next->prev = p = p->prev->next
```

```
p 元素 a(i)
p->next 元素 a(i+1)

插入结点 s 元素 e
步骤如下：
s->prev = p; /* 把 p 赋值给 s 的前驱 */
s->next = p->next; /* 把 p->next 赋值给 s 的后继 */

p->next->prev = s; /* 把 s 赋值给 p->next 的前驱 */
p->next = s; /* 把 s 赋值给 p 的后继 */

顺序就是先搞定 s 的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。
```

