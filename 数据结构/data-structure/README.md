> 浙江大学MOOC
# 数据结构

## 基本概念
### 数据结构
- **数据对象**在计算机中的组织方式
    - 逻辑结构（一对一 线性结构；一对多 树结构； 多对多 图结构）
    - 物理存储结构
- 数据对象必定与一系列加在其上的**操作**相关联
- 完成这些操作所用的方法就是**算法**

### 抽象数据类型（Abstract Data Type）
- 数据类型
    - 数据对象集（二维数组？一维数组？十字链表？来存储，抽象并不关心这些）
    - 数据集合相关联的操作集（加法？先加行还是先加列？抽象也不关心这些）
- 抽象：描述数据类型的方法不依赖于具体实现
    - 与存放数据的机器无关
    - 与数据存储的物理结构无关
    - 与实现操作的算法和编程语言均无关

### 算法
- 一个有限指令集
- 接收一些输入（有些情况下不需要输入）

#### 好的算法
- 空间复杂度 S(n) 程序执行时占用存储单元的长度
- 时间复杂度 T(n) 程序执行时耗费时间的长度

#### 分析算法
- 最坏情况复杂度
- 平均复杂度

#### 复杂度的渐近表示法

## 第二讲 线性结构

## 第4章 树
树是一种十分重要的非线性数据结构。

树是n个结点构成的有限集合。当n=0时，称为空树。

### 二叉树
一个二叉树是一个有穷的结点集合。

- **斜二叉树**，又称**退化二叉树**，深度达到最大`N`，已退化为线性表。
- **完美二叉树**，又称**满二叉树**，所有分支结点都存在左子树和右子树，并且所有叶结点都在同一层上。
- **完全二叉树**，深度为`k`的有`n`个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为`i`的结点与满二叉树中的编号为`i`的结点在二叉树中的位置相同。

#### 二叉树的存储结构
**顺序存储结构**，通常用于完全二叉树的存储。

缺点：不易实现增加、删除操作。


### 二叉树遍历
[程序](./t4-1.c)

#### 前序遍历步骤
![二叉树](https://images2015.cnblogs.com/blog/795187/201510/795187-20151023201552927-578458496.png)

该图的**前序遍历**结果：`GDAFEMHZ`
1. 打印该节点（再三考虑还是把访问根节点这句话去掉了）
1. 访问左子树，返回到第一步（注意：返回到第一步的意思是将根节点的左子树作为新的根节点，就好比图中D是G的左子树但是D也是A节点和F节点的根节点）
1. 访问右子树，返回到第一步
1. 结束递归，返回到上一个节点

前序遍历另一种方式：（在完成第2，3步的时候，也是要按照前序遍历二叉树的规则完成）
1. 访问根节点
1. 前序遍历左子树
1. 前序遍历右子树

#### 中序遍历步骤
该图的**中序遍历**为：`ADEFGHMZ`
1. 访问该节点左子树
1. 若该节点有左子树，则返回第一步，否则打印该节点
1. 若该节点有右子树，则返回第一步，否则结束递归并返回上一节点

中序遍历的另一种表述：（在完成第1，3步的时候，要按照中序遍历的规则来完成）
1. 中序遍历左子树
1. 访问根节点
1. 中序遍历右子树

#### 后序遍历步骤
该图的**后序遍历**为：`AEFDHZMG`
1. 访问左子树；
1. 若该节点有左子树，返回第一步；
1. 若该节点有右子树，返回第一步，**否则打印该节点并返回上一节点**。

后序遍历的另一种表述：（在完成1，2步的时候，依然要按照后序遍历的规则来完成）
1. 后序遍历左子树
1. 后序遍历右子树
1. 访问根节点

---
进入正题，已知两种遍历结果求另一种遍历结果（其实就是重构二叉树）[Link](https://www.cnblogs.com/lanhaicode/p/10390147.html)

第一种：已知前序遍历、中序遍历求后序遍历
前序遍历：ABCDEF

中序遍历：CBDAEF

求后续遍历：

在进行分析前读者需要知道不同遍历结果的特点

- **前序遍历**的第一元素是整个二叉树的根节点
- **中序遍历**中根节点的左边的元素是左子树，根节点右边的元素是右子树
- **后序遍历**的最后一个元素是整个二叉树的根节点


中序遍历：CBDAEF

后序遍历为：CDBFEA

（如果读者不明白上述三个特点，建议再回去看一下三种不同遍历对应的代码，并在纸上写出一个简单的二叉树的三种不同的遍历结果，以加深对三种不同遍历的理解）


**注意：已知前序遍历、后序遍历无法求出中序遍历（因为由前序后序重构出来的二叉树不止一种）**